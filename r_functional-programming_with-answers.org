#+OPTIONS: title:t date:t author:t email:t
#+OPTIONS: toc:t h:6 num:t |:t todo:nil
#+OPTIONS: *:t -:t ::t <:t \n:t e:t creator:nil
#+OPTIONS: f:t inline:t tasks:t tex:t timestamp:t
#+OPTIONS: html-preamble:t html-postamble:nil

#+PROPERTY: header-args:R :session R:purrr :eval no :exports code :tangle yes :comments link

#+TITLE:   Functional programming in R (with purrr)
#+DATE:	   {{{time(%B %d\, %Y)}}}
#+AUTHOR:  Marie-Hélène Burle
#+EMAIL:   msb2@sfu.ca

* Introduction

** What is functional programming?

It is a programming paradigm based on the evaluation of functions. This is opposed to /imperative  programming/. Some languages are based strictly on functional programming (e.g. Haskell), others 

** Iterations

Repetition of a process (e.g. applying the same function to several variables).

Classic methods:
- loops
- src_R[:eval no]{apply} functions family

** The purrr package

One of the src_R[:eval no]{tidyverse} core packages, src_R[:eval no]{purrr} was written a few years ago by [[https://github.com/lionel-][Lionel Henry]] (also the maintainer), [[http://hadley.nz/][Hadley Wickham]], and [[https://www.rstudio.com/][RStudio inc.]] 

*** Goal

src_R[:eval no]{Purrr} is a set of tools allowing consistent functional programming in R in a src_R[:eval no]{tidyverse} style (using src_R[:eval no]{magrittr} pipes and following the same naming conventions found in other src_R[:eval no]{tidyverse} packages).

As Hadley Wickham says, in many ways, src_R[:eval no]{purrr} is the equivalent of the src_R[:eval no]{dplyr}, but while src_R[:eval no]{dplyr} focuses on data frames, src_R[:eval no]{purrr} works on vectors: it works on the elements of atomic vectors, lists, and data frames.

*** Logistics

Install it with:

#+BEGIN_SRC R
install.packages("tidyverse")
## or
install.packages("purrr")
#+END_SRC

Load it with:

#+BEGIN_SRC R
library(tidyverse)
## or
library(purrr)
#+END_SRC

As always, once the package is loaded, you can get information on the package with:

#+BEGIN_SRC R
?purrr
#+END_SRC

and on any of its functions with:

#+BEGIN_SRC R
?function

## e.g. for the map function
?map
#+END_SRC

* Let's dive in

** Load packages

First, let's load the packages that we will use. It is always a good idea to write all the packages that you will be using at the top of the script. This will help others, using your script, to know what is required to run it.

#+BEGIN_SRC R
library(tidyverse)   # we will use purrr and other core packages
library(magrittr)    # we will use several types of pipes
library(patchwork)   # this is a cool package to plot several graphs together
#+END_SRC

** Create some fake banding data

Let's create some imaginary bird banding data:

#+BEGIN_SRC R
banding <- data.frame(
  bird = paste0("bird", 1:50),
  sex = sample(c("F", "M"), 50, replace = T),
  population = sample(LETTERS[1:3], 50, replace = T),
  mass = rnorm(50, 43, 4) %>% round(1),
  tarsus = rnorm(50, 27, 1) %>% round(1),
  wing = rnorm(50, 112, 3) %>% round(0)
)

banding

banding %>% str()
#+END_SRC

** Modify: modify elements of a list

As is the case with data frames, we can see that the 3 string variables (bird, sex, and population) have been converted to factors. What if we decide to convert all those factors into character vectors.

#+BEGIN_VERBATIM
How would you do this?
Spend 5 minutes writing code you would usually use.
#+END_VERBATIM

To modify the elements of a list, you can use the src_R[:eval no]{modify()} functions family.

*** Usage

#+BEGIN_SRC R
modify(.x, .f, ...)
modify_if(.x, .p, .f, ...)
modify_at(.x, .at, .f, ...)
#+END_SRC

#+BEGIN_EXAMPLE
.x     a list or atomic vector
.f     a function, formula, or atomic vector
...    additional arguments passed to .f
.p     a predicate function.
       Only the elements for which .p evaluates to TRUE will be modified
.at    a character vector of names or a numeric vector of positions.
       Only the elements corresponding to .at will be modified
#+END_EXAMPLE

For every element of src_R[:eval no]{.x}, apply src_R[:eval no]{.f}, and return a modified version of src_R[:eval no]{.x}.

So basically, in its simplest form, we have:

#+BEGIN_MONO
modify(list, function)
#+END_MONO

*** Apply to our example

Now, this is how all factors in our data frame can be converted into character vectors using src_R[:eval no]{modify_if()}:

#+BEGIN_SRC R
banding %<>%
  modify_if(is.factor, as.character) %T>%
  str()
#+END_SRC

The modify family includes src_R[:eval no]{modify()}, src_R[:eval no]{modify_if()}, src_R[:eval no]{modify_at()}, and src_R[:eval no]{modify_depth}. That last one will make sense later.

#+BEGIN_QUOTE
Wait: what were all these weird looking pipes??
#+END_QUOTE

*** Magrittr digression: less used piping treasures

src_R[:eval no]{%<>%} pipes the left expression to the right, and then back to the left. Instead of a right arrow, think of it as an arrow going from left to right, making a turn and going back to its starting place again.

The code:

#+BEGIN_SRC R
banding %<>%
  modify_if(is.factor, as.character) %T>%
  str()
#+END_SRC

that we used above, is equivalent to:

#+BEGIN_SRC R
banding <-
  banding %>%
  modify_if(is.factor, as.character) %T>%
  str()
#+END_SRC

src_R[:eval no]{%T%} pipes the effect of the left expression to the right, but does not pipe the object itself (so the object is "free" to be used by another pipe). This is very useful when you want to produce to output from one object. Or produce a side effect (e.g. printing) without interrupting a pipeline. I like to think of the "T" as a branching which represents the 2 outputs produced by a single object.

#+BEGIN_VERBATIM
Try replacing src_R[:eval no]{%T%} with the regular pipe src_R[:eval no]{%>%} in our code and see what happens.
Can you explain it?
#+END_VERBATIM

There are other pipes in [[https://github.com/tidyverse/magrittr][this amazing package]]. You should explore them at your own time!

** Map: apply functions to elements of a list

Now, let's imagine that we want to plot the effect of tarsus length on mass, but that we want to graph each population separately.

#+BEGIN_VERBATIM
How would you do this?
Spend 5 minutes writing code you would usually use.
#+END_VERBATIM

To apply functions to elements of a list, you can use the src_R[:eval no]{map} functions family.

*** Usage

#+BEGIN_SRC R
map(.x, .f, ...)
map_if(.x, .p, .f, ...)
map_at(.x, .at, .f, ...)
#+END_SRC

#+BEGIN_EXAMPLE
.x     a list or atomic vector
.f     a function, formula, or atomic vector
...     additional arguments passed to .f
.p     a predicate function.
       Only the elements for which .p evaluates to TRUE will be modified
.at    a character vector of names or a numeric vector of positions.
       Only the elements corresponding to .at will be modified
#+END_EXAMPLE

For every element of src_R[:eval no]{.x}, apply src_R[:eval no]{.f}.

What we have, in the simplest case, is:

#+BEGIN_MONO
map(list, function)
#+END_MONO

*** Apply to our example

This is how we can do this, using src_R[:eval no]{map()}:

#+BEGIN_SRC R
graphs <-
  banding %>%
  split(.$population) %>%
  map(~ ggplot(., aes(tarsus, mass)) + geom_point())
#+END_SRC

And using the amazingly easily package [[https://github.com/thomasp85/patchwork][patchwork]], we can plot them all side by side very easily with:

#+BEGIN_SRC R
graphs[[1]] + graphs[[2]] + graphs[[3]]
#+END_SRC

** Walk: apply side effects to elements of a list

Now that we have our 3 graphs, we want to save them to 3 files.

#+BEGIN_VERBATIM
How would you do this?
Spend 5 minutes writing code you would usually use.
#+END_VERBATIM

To apply side effects to elements of a list, we use the src_R[:eval no]{walk} functions family.

*** Usage

#+BEGIN_SRC R
walk(.x, .f, ...)
#+END_SRC

#+BEGIN_EXAMPLE
.x     a list or atomic vector
.f     a function, formula, or atomic vector
...     additional arguments passed to .f
#+END_EXAMPLE

*** Apply to our example

We already have a list of graphs: src_R[:eval no]{graphs}. Now, we can create a list of paths where we want to save them:

#+BEGIN_SRC R
paths <- paste0("population_", names(graphs), ".png")
#+END_SRC

So we want to save each element of src_R[:eval no]{graph} (a graph) into an element of src_R[:eval no]{paths} (a path). The function we will use is src_R[:eval no]{ggsave}. To apply it to all of our elements, instead of using src_R[:eval no]{map}, we will use src_R[:eval no]{walk} because we are not trying to create a new object.

The problem is that we have 2 lists to deal with. src_R[:eval no]{Map} and src_R[:eval no]{walk} only allow to deal with one list. But src_R[:eval no]{map2} and src_R[:eval no]{walk2} allow to deal with 2 lists (src_R[:eval no]{pmap} and src_R[:eval no]{pwalk} allow to deal with any number of lists).

Here is how src_R[:eval no]{walk2} works (it is the same for src_R[:eval no]{map2}):

#+BEGIN_SRC R
walk2(.x, .y, .f, ...)
#+END_SRC

#+BEGIN_EXAMPLE
.x, .y   vectors of the same length.
         A vector of length 1 will be recycled.
.f       a function, formula, or atomic vector
...       additional arguments passed to .f
#+END_EXAMPLE

#+BEGIN_VERBATIM
Give it a try:
use src_R[:eval no]{walk2} to save the elements of src_R[:eval no]{graphs} into the elements of src_R[:eval no]{paths} using src_R[:eval no]{ggsave}.
Don't hesitate to look up the help file for src_R[:eval no]{ggsave} with src_R[:eval no]{?ggsave} if you don't remember how to use it!
#+END_VERBATIM

#+BEGIN_accordion
Answer
#+END_accordion

#+HTML: <div class="panel">
#+BEGIN_SRC R
walk2(paths, graphs, ggsave)
#+END_SRC
#+HTML: </div>

* Your turn!

** Create new fake data

This time, imagine that bird1 to bird5 are kept in captivity. Their mass is monitored regularly to make sure they are not loosing weight.

How can we create such data?

We could, of course, write it a tedious way:

#+BEGIN_SRC R
mass <- data.frame(
  bird1 = runif(15, 35, 55) %>% round(1),
  bird2 = runif(15, 35, 55) %>% round(1),
  bird3 = runif(15, 35, 55) %>% round(1),
  bird4 = runif(15, 35, 55) %>% round(1),
  bird5 = runif(15, 35, 55) %>% round(1)
)
#+END_SRC

But Hadley Wickham's rule is that we should never copy-paste more than twice. Uh hum... we have 5 copies of the same line of code already :P And if we wanted to create a larger data frame, we could have many more than that!

#+BEGIN_VERBATIM
Using the src_R[:eval no]{map()} function to get to the same result, how would you do this?
Spend 5 min brainstorming on this and feel free to talk to each other!
#+END_VERBATIM

#+BEGIN_accordion
Answer
#+END_accordion

#+HTML: <div class="panel">
#+BEGIN_SRC R
n_birds <- 1:15

df <-
  map(n_birds, ~ runif(10, 35, 55) %>% round(1)) %>%
  data.frame() %>%
  set_names(map(n_birds, ~ paste0("bird", .)))

df

df %>% str()
#+END_SRC
#+HTML: </div>

** Apply functions to each variable

How could you calculate the mean for each bird?

#+BEGIN_VERBATIM
Spend 3 min to think about how to do this using src_R[:eval no]{map()}.
Feel free to chat with whoever you'd like to.
#+END_VERBATIM

#+BEGIN_accordion
Answer
#+END_accordion

#+HTML: <div class="panel">
#+BEGIN_SRC R
map(df, mean)
#+END_SRC
#+HTML: </div>

However, the output of src_R[:eval no]{map()} is always a list. And a list as output is not really convenient here. There are other map functions which have vector or data frame outputs. To get a numeric vector as the output, we use src_R[:eval no]{map_dbl()}:

#+BEGIN_accordion
Answer
#+END_accordion

#+HTML: <div class="panel">
#+BEGIN_SRC R
map_dbl(df, mean)
#+END_SRC
#+HTML: </div>

Similarly, you can calculate the variance, the sum, look for the largest value, or apply any other function to our data.

#+BEGIN_VERBATIM
Spend 2 min writing codes for these.
#+END_VERBATIM

#+BEGIN_accordion
Answer
#+END_accordion

#+HTML: <div class="panel">
#+BEGIN_SRC R
map_dbl(df, var)
map_dbl(df, sum)
map_dbl(df, max)
#+END_SRC
#+HTML: </div>

* Summary of the map and walk functions family

We will use different src_R[:eval no]{map} (or src_R[:eval no]{walk}, if we want the side effects) function depending on:

#+BEGIN_VERSE
- How many lists we are using in the input
#+END_VERSE

| number of arguments in input |   |   | purrr function    |
|------------------------------+---+---+-------------------|
|                            1 |   |   | =map= or =walk=   |
|                            2 |   |   | =map2= or =walk2= |
|                         more |   |   | =pmap= or =pwalk= |

#+HTML: <br>

#+BEGIN_VERSE
- The class of the output we want
#+END_VERSE

| class we want for the output   |   |   | purrr function |
|--------------------------------+---+---+----------------|
| nothing*                       |   |   | =walk=         |
| list*                          |   |   | =map=          |
| double                         |   |   | =map_dbl=      |
| integer                        |   |   | =map_int=      |
| character                      |   |   | =map_chr=      |
| logical                        |   |   | =map_lgl=      |
| data frame (by row-binding)    |   |   | =map_dfr=      |
| data frame (by column-binding) |   |   | =map_dfc=      |

#+HTML: <br>

Results are returned predictably and consistently, which is [[https://blog.rstudio.com/2016/01/06/purrr-0-2-0/][not the case]] of src_R[:eval no]{sapply()}.

*As Jenny Bryan [[https://speakerdeck.com/jennybc/data-rectangling][said it nicely]]:

#+BEGIN_QUOTE
"src_R[:eval no]{walk()} can be thought of as src_R[:eval no]{map_nothing()}

src_R[:eval no]{map()} can be thought of as src_R[:eval no]{map_list()}"
#+END_QUOTE

#+HTML: <br>

#+BEGIN_VERSE
- How we want to select the input
#+END_VERSE

| selecting input based on |   |   | purrr function |
|--------------------------+---+---+----------------|
| condition                |   |   | =map_if=       |
| location                 |   |   | =map_at=       |

* Formulas: a shorter notation for anonymous functions

** With one element

The code:

#+BEGIN_SRC R
function(x) x + 3
#+END_SRC

can be written as:

#+BEGIN_SRC R
~ . + 3
#+END_SRC

#+BEGIN_VERBATIM
Your turn: write the following anonymous function as a formula.
#+END_VERBATIM

#+BEGIN_SRC R
function(x) mean(x) + 3
#+END_SRC

#+BEGIN_accordion
Answer
#+END_accordion

#+HTML: <div class="panel">
#+BEGIN_SRC R
~ mean(.) + 3
#+END_SRC
#+HTML: </div>

** With 2 elements

The code:

#+BEGIN_SRC R
function(x, y) x + y
#+END_SRC

can be shortened to:

#+BEGIN_SRC R
~ .x + .y
#+END_SRC

*** Referring to elements

| 1st element |   | 2nd element |   | 3rd element |
|-------------+---+-------------+---+-------------|
| =.=         |   |             |   |             |
| =.x=        |   | =.y=        |   |             |
| =..1=       |   | =..2=       |   | =..3=       |

etc.

#+BEGIN_VERBATIM
Your turn: write the following anonymous function as a formula.
#+END_VERBATIM

#+BEGIN_SRC R
function(x1, x2, y) lm(y ~ x1 + x2)
#+END_SRC

#+BEGIN_accordion
Answer
#+END_accordion

#+HTML: <div class="panel">
#+BEGIN_SRC R
~ lm(..3 ~ ..1 + ..2)
#+END_SRC
#+HTML: </div>

# * Nested data frames

# A nested data frame is a data frame of data frames: some of the cells of this master data frame contains data frames as values. Of course, there is no limit to that and you can have data frames nested within data frames nested within data frames nested within... you get the idea. This leads to the concept of "depth".

# * List columns

# A list column is a data frame in which some of the columns are made of lists instead of atomic vectors.

* Conclusion

These are the most important src_R[:eval no]{purrr} functions. But there are others that you should explore :)

#+HTML: <script>; var acc = document.getElementsByClassName("accordion"); var i; for (i = 0; i < acc.length; i++) {; acc[i].addEventListener("click", function() {; this.classList.toggle("active"); var panel = this.nextElementSibling; if (panel.style.maxHeight){; panel.style.maxHeight = null; } else {; panel.style.maxHeight = panel.scrollHeight + "px"; }; }); }; </script>
